---
aliases:
  - Deadlock
importance: Medium
originated from:
  - "[[ğŸ“˜ ì½”í‹€ë¦° ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°/1ì¥ - Hello, Concurrent World!]]"
answered by:
  - Book
  - OpenAI
tags:
  - Coroutine
  - ì½”ë£¨í‹´
  - Terms
  - ì£¼ìš”_ê°œë…
learned:
---
##### â„¹ï¸ Description
---
- [ìŠ¤ë ˆë“œ](ìŠ¤ë ˆë“œ.md) ë˜ëŠ” [ì½”ë£¨í‹´](ì½”ë£¨í‹´.md) ê°™ì€ ì—¬ëŸ¬ ì‹¤í–‰ íë¦„ì´ ì„œë¡œê°€ ê°€ì§„ ìì›ì„ ê¸°ë‹¤ë¦¬ë©°ë¬´í•œíˆ ëŒ€ê¸°í•˜ëŠ” ë¬¸ì œ

##### ğŸ”¥ How does it occur?
---
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
	    val name = coroutineContext[CoroutineName]?.name
	    
	    println("$name is started...")
        
        mutexA.lock()
        
        println("$name: Mutex A is locked...")
        
        delay(100)
        mutexB.lock()
        
        println("$name: Mutex B is locked...")
        
        mutexA.unlock()
        mutexB.unlock()
		
		println("$name is done...")
    }
    launch(context = CoroutineName("Coroutine 2")) {
	    val name = coroutineContext[CoroutineName]?.name
	    
	    println("$name is started...")
	    
        mutexB.lock()
        
        println("$name: Mutex B is locked...")
        
        delay(100)
        mutexA.lock()
        
        println("$name: Mutex A is locked...")
        
        mutexB.unlock()
        mutexA.unlock()
		
		println("$name is done...")
    }
}
```

##### ğŸ§¯ How to handle?
---
- ë½ íšë“ ìˆœì„œ ì¼ì¹˜
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
	    val name = coroutineContext[CoroutineName]?.name
	    
		acquireInOrder(
            name = name,
            mutexA = mutexA,
            mutexB = mutexB
        ) {
            println("$name is done...")
        }
    }
    launch(context = CoroutineName("Coroutine 2")) {
	    val name = coroutineContext[CoroutineName]?.name
	    
		acquireInOrder(
            name = name,
            mutexA = mutexA,
            mutexB = mutexB
        ) {
            println("$name is done...")
        }
    }
}

suspend fun acquireInOrder(
    name: String?,
    mutexA: Mutex,
    mutexB: Mutex,
    block: suspend () -> Unit
) {
    println("$name is started...")
    
    mutexA.lock()
    
    println("$name: Mutex A is locked...")
    
    delay(100)
    
    try {
        mutexB.lock()
        
        println("$name: Mutex B is locked...")
        
        try {
            block()
        } finally {
            mutexB.unlock()
        }
    } finally {
        mutexA.unlock()
    }
}
```
- [withTimeout](withTimeout.md)ì„ ì‚¬ìš©í•˜ì—¬ ì˜¤ë˜ ê¸°ë‹¤ë¦¬ê²Œ ë˜ë©´ í¬ê¸°
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
        val name = coroutineContext[CoroutineName]?.name
        
        println("$name is started...")
        
        tryLockWithTimeout(
            name = name,
            mutex = mutexA,
            timeMillis = 100L
        )
        delay(100)
        tryLockWithTimeout(
            name = name,
            mutex = mutexB,
            timeMillis = 100L
        )
        mutexA.takeIf { it.isLocked }?.unlock()
        mutexB.takeIf { it.isLocked }?.unlock()
        
        println("$name is done...")
    }
    launch(context = CoroutineName("Coroutine 2")) {
        val name = coroutineContext[CoroutineName]?.name
        
        tryLockWithTimeout(
            name = name,
            mutex = mutexB,
            timeMillis = 100L
        )
        delay(100)
        tryLockWithTimeout(
            name = name,
            mutex = mutexA,
            timeMillis = 200L
        )
        mutexB.takeIf { it.isLocked }?.unlock()
        mutexA.takeIf { it.isLocked }?.unlock()
        
        println("$name is done...")
    }
}

suspend fun tryLockWithTimeout(
    name: String?,
    mutex: Mutex,
    timeMillis: Long
): Boolean = try {
    withTimeout(timeMillis = timeMillis) {
        mutex.lock()
        
        println("$name: Mutex is locked...")
        
        true
    }
} catch (e: TimeoutCancellationException) {
    println("$name: Mutex is cancelled...")
    
    false
}
```
