---
aliases:
  - Unstructured Concurrency
  - 구조화 깨기
importance: High
originated from:
  - "[[📘 코틀린 코루틴의 정석/7장 - 구조화된 동시성]]"
answered by:
  - Book
  - OpenAI
tags:
  - Coroutine
  - 코루틴
  - Terms
  - 주요_개념
learned:
---
##### ℹ️ Description
---
- [CoroutineScope](CoroutineScope.md)의 [코루틴](코루틴.md) 범위에 벗어나는 것

##### 🔮 Effect
---
- [비동기 작업](비동기%20작업.md)을 안전하지 않게 만들기 때문에 최대한 지양해야 함

##### 🏗️ How to unstructured?
---
- `CoroutineScope`를 생성해 기존 `CoroutineScope` 범위에서 벗어나기
	- `CoroutineScope`가 생성되면 새로운 [루트 Job](루트%20Job.md)이 생성되며, 구조화를 깰 수 있음
```Kotlin
launch {
    CoroutineScope(CoroutineName("Root")).launch {
    }
}
```
- [Job](Job.md)을 사용해 구조화 깨기
	- `Job`의 `parent` 인자로 아무것도 넘기지 않기에 루트 `Job`이 되며, 구조화를 깰 수 있음
	- `Job`의 `parent` 인자로 [부모 코루틴](부모%20코루틴.md)의 `Job`을 넘기면, 구조화가 깨지지 않음
	- `Job` 생성 함수를 통해 생성된 `Job` 객체는 [자식 코루틴](자식%20코루틴.md)들이 모두 실행 완료되더라도 자동으로 완료되지 않기에, [complete](CompletableJob.complete.md) 함수를 호출해야 완료됨
```Kotlin
runBlocking {
    val rootJob = Job()

    launch(context = CoroutineName("Coroutine1") + rootJob) {
        launch(CoroutineName("Coroutine2")) {
            // do something...
        }
    }
    rootJob.complete()
}
```

```Kotlin
runBlocking {
    val job = Job(parent = coroutineContext[Job])

	launch(CoroutineName("Coroutine1") + job) {
        launch(CoroutineName("Coroutine2")) {
            // do something...
        }
	}
	job.complete()
}
```
