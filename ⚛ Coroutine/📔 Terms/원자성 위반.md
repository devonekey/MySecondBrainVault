---
aliases:
  - Atomicity Violation
importance: Medium
originated from:
  - "[[📘 코틀린 동시성 프로그래밍/1장 - Hello, Concurrent World!]]"
answered by:
  - Book
  - OpenAI
tags:
  - Coroutine
  - 코루틴
  - Terms
  - 주요_개념
learned:
---
##### ℹ️ Description
---
- 여러 개의 연산을 하나의 단위처럼 처리해야 하는 데, 도중에 다른 [스레드](스레드.md)나 [코루틴](코루틴.md) 같은 실행 흐름이 끼어들어 값이 엉키는 문제

##### 🔥 How does it occur?
---
```Kotlin
fun main() = runBlocking {
    val map = hashMapOf<Int, Boolean>()
    
    repeat(1_000) {
        launch(context = Dispatchers.Default) {
            if (!map.contains(it)) {
                map[it] = true
            }
        }
    }
    
    delay(1_000)
    
    println("count: ${list.count()}")
}
```
- 연산이 하나의 단위로 실행되지 않을 때 발생

##### 🧯 How to handle?
---
- 상태가 동시에 수정될 수 있을 때 [원자성](원자성.md)이 필요하며, 상태의 수정이 겹치지 않도록 보장해야 함
- [Mutex](Mutex.md) 사용
```Kotlin
fun main() = runBlocking {
    val map = hashMapOf<Int, Boolean>()
    val mutex = Mutex()
    
    repeat(1_000) {
        launch(context = Dispatchers.Default) {
            mutex.withLock {
                if (!map.contains(it)) {
                    map[it] = true
                }
            }
        }
	}
    delay(1_000)
    
    println("count: ${list.count()}")
}
```
- 원자적 자료 구조 사용
```Kotlin
fun main() = runBlocking {
    val map = ConcurrentHashMap<Int, Boolean>()
    
    repeat(1_000) {
        launch(context = Dispatchers.Default) {
            map.putIfAbsent(it, true)
        }
    }
    delay(1_000)
    
    println("count: ${map.count()}")
}
```
