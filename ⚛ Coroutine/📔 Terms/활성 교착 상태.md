---
aliases:
  - Livelock
  - í™œë½ ìƒíƒœ
importance: Medium
originated from:
  - "[[ğŸ“˜ ì½”í‹€ë¦° ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°/1ì¥ - Hello, Concurrent World!]]"
answered by:
  - Book
  - GPT
tags:
  - Coroutine
  - ì½”ë£¨í‹´
  - Terms
  - ì£¼ìš”_ê°œë…
learned:
---
##### â„¹ï¸ Description
---
- ë‘˜ ì´ìƒì˜ ì‹¤í–‰ íë¦„ì´ ì„œë¡œ ìì›ì„ ì–‘ë³´í•˜ëŠë¼ ë¬´í•œíˆ ëŒ€ê¸°í•˜ëŠ” ë¬¸ì œ

##### ğŸ”¥ How does it occur?
---
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
        val name = coroutineContext[CoroutineName]?.name
        
        while (true) {
            if (mutexA.tryLock()) {
                delay(100)
                
                if (mutexB.tryLock()) {
                    println("$name is done...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                    mutexB.takeIf { it.isLocked }?.unlock()
                    
                    break
                } else {
                    println("$name unlocked Mutex A...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                }
            }
        }
    }
    launch(context = CoroutineName("Coroutine 2")) {
        val name = coroutineContext[CoroutineName]?.name
        
        while (true) {
            if (mutexB.tryLock()) {
                delay(100)
                
                if (mutexA.tryLock()) {
                    println("$name is done...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                    mutexB.takeIf { it.isLocked }?.unlock()
                    
                    break
                } else {
                    println("$name unlocked Mutex B...")
                    
                    mutexB.takeIf { it.isLocked }?.unlock()
                }
            }
        }
    }
}
```

##### ğŸ§¯ How to handle?
---
- ë°±ì˜¤í”„ ì „ëµ ì ìš©
  â†’ ë°˜ë³µì ìœ¼ë¡œ ì‹¤íŒ¨ í•  ë•Œ ì ê¹ ê¸°ë‹¤ë¦¬ëŠ” ì‹œê°„ì„ ëŠ˜ë ¤ ì¶©ëŒ íšŒí”¼
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
        val name = coroutineContext[CoroutineName]?.name
        var backoff = 10L
        
        while (true) {
            if (mutexA.tryLock()) {
                delay(100)
                
                if (mutexB.tryLock()) {
                    println("$name is done...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                    mutexB.takeIf { it.isLocked }?.unlock()
                    
                    break
                } else {
                    println("$name unlocked Mutex A...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()  
					delay(backoff)
					
					backoff = (backoff * 2).coerceAtMost(1_000)
                }
            }
        }
    }
    launch(context = CoroutineName("Coroutine 2")) {
        val name = coroutineContext[CoroutineName]?.name
        
        while (true) {
            if (mutexB.tryLock()) {
                delay(100)
                
                if (mutexA.tryLock()) {
                    println("$name is done...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                    mutexB.takeIf { it.isLocked }?.unlock()
                    
                    break
                } else {
                    println("$name unlocked Mutex B...")
                    
                    mutexB.takeIf { it.isLocked }?.unlock()
                }
            }
        }
    }
}
```
- ë½ íšë“ ìˆœì„œ ì¼ì¹˜
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
        val name = coroutineContext[CoroutineName]?.name
        var loop = true
        
        while (loop) {
            acquireInOrder(
                name = name,
                mutexA = mutexA,
                mutexB = mutexB
            ) {
                loop = false
                
                println("$name is done...")
            }
        }
    }
    launch(context = CoroutineName("Coroutine 2")) {
        val name = coroutineContext[CoroutineName]?.name
        var loop = true
        
        while (loop) {
            acquireInOrder(
                name = name,
                mutexA = mutexA,
                mutexB = mutexB
            ) {
                loop = false
                
                println("$name is done...")
            }
        }
    }
}

suspend fun acquireInOrder(
    name: String?,
    mutexA: Mutex,
    mutexB: Mutex,
    block: suspend () -> Unit
) {
    println("$name is started...")
    
	mutexA.lock()
    delay(100)
    
    try {
        mutexB.lock()
        
        try {
            block()
        } finally {
            mutexB.unlock()
            
            println("$name: Mutex B is unlocked...")
        }
    } finally {
        mutexA.unlock()
        
        println("$name: Mutex A is unlocked...")
    }
}
```
