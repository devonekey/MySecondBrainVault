---
aliases:
  - Livelock
  - 활락 상태
importance: Medium
originated from:
  - "[[📘 코틀린 동시성 프로그래밍/1장 - Hello, Concurrent World!]]"
answered by:
  - Book
  - OpenAI
tags:
  - Coroutine
  - 코루틴
  - Terms
  - 주요_개념
learned:
---
##### ℹ️ Description
---
- 둘 이상의 실행 흐름이 서로 자원을 양보하느라 무한히 대기하는 문제

##### 🔥 How does it occur?
---
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
        val name = coroutineContext[CoroutineName]?.name
        
        while (true) {
            if (mutexA.tryLock()) {
                delay(100)
                
                if (mutexB.tryLock()) {
                    println("$name is done...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                    mutexB.takeIf { it.isLocked }?.unlock()
                    
                    break
                } else {
                    println("$name unlocked Mutex A...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                }
            }
        }
    }
    launch(context = CoroutineName("Coroutine 2")) {
        val name = coroutineContext[CoroutineName]?.name
        
        while (true) {
            if (mutexB.tryLock()) {
                delay(100)
                
                if (mutexA.tryLock()) {
                    println("$name is done...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                    mutexB.takeIf { it.isLocked }?.unlock()
                    
                    break
                } else {
                    println("$name unlocked Mutex B...")
                    
                    mutexB.takeIf { it.isLocked }?.unlock()
                }
            }
        }
    }
}
```

##### 🧯 How to handle?
---
- 백오프 전략 적용
  → 반복적으로 실패 할 때 잠깐 기다리는 시간을 늘려 충돌 회피
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
        val name = coroutineContext[CoroutineName]?.name
        var backoff = 10L
        
        while (true) {
            if (mutexA.tryLock()) {
                delay(100)
                
                if (mutexB.tryLock()) {
                    println("$name is done...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                    mutexB.takeIf { it.isLocked }?.unlock()
                    
                    break
                } else {
                    println("$name unlocked Mutex A...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()  
					delay(backoff)
					
					backoff = (backoff * 2).coerceAtMost(1_000)
                }
            }
        }
    }
    launch(context = CoroutineName("Coroutine 2")) {
        val name = coroutineContext[CoroutineName]?.name
        
        while (true) {
            if (mutexB.tryLock()) {
                delay(100)
                
                if (mutexA.tryLock()) {
                    println("$name is done...")
                    
                    mutexA.takeIf { it.isLocked }?.unlock()
                    mutexB.takeIf { it.isLocked }?.unlock()
                    
                    break
                } else {
                    println("$name unlocked Mutex B...")
                    
                    mutexB.takeIf { it.isLocked }?.unlock()
                }
            }
        }
    }
}
```
- 락 획득 순서 일치
```Kotlin
fun main() = runBlocking<Unit> {
    val mutexA = Mutex()
    val mutexB = Mutex()
    
    launch(context = CoroutineName("Coroutine 1")) {
        val name = coroutineContext[CoroutineName]?.name
        var loop = true
        
        while (loop) {
            acquireInOrder(
                name = name,
                mutexA = mutexA,
                mutexB = mutexB
            ) {
                loop = false
                
                println("$name is done...")
            }
        }
    }
    launch(context = CoroutineName("Coroutine 2")) {
        val name = coroutineContext[CoroutineName]?.name
        var loop = true
        
        while (loop) {
            acquireInOrder(
                name = name,
                mutexA = mutexA,
                mutexB = mutexB
            ) {
                loop = false
                
                println("$name is done...")
            }
        }
    }
}

suspend fun acquireInOrder(
    name: String?,
    mutexA: Mutex,
    mutexB: Mutex,
    block: suspend () -> Unit
) {
    println("$name is started...")
    
	mutexA.lock()
    delay(100)
    
    try {
        mutexB.lock()
        
        try {
            block()
        } finally {
            mutexB.unlock()
            
            println("$name: Mutex B is unlocked...")
        }
    } finally {
        mutexA.unlock()
        
        println("$name: Mutex A is unlocked...")
    }
}
```
